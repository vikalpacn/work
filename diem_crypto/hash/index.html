<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module defines traits and implementations of cryptographic hash functions for the Diem project."><meta name="keywords" content="rust, rustlang, rust-lang, hash"><title>diem_crypto::hash - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../diem_crypto/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../diem_crypto/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module hash</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#statics">Statics</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../index.html">diem_crypto</a>::<wbr><a class="mod" href="#">hash</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/diem_crypto/hash.rs.html#4-685">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module defines traits and implementations of
<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash functions</a>
for the Diem project.</p>
<p>It is designed to help authors protect against two types of real world attacks:</p>
<ol>
<li>
<p><strong>Semantic Ambiguity</strong>: imagine that Alice has a private key and is using
two different applications, X and Y. X asks Alice to sign a message saying
“I am Alice”. Alice accepts to sign this message in the context of X. However,
unbeknownst to Alice, in application Y, messages beginning with the letter “I”
represent transfers. “ am “ represents a transfer of 500 coins and “Alice”
can be interpreted as a destination address. When Alice signed the message she
needed to be aware of how other applications might interpret that message.</p>
</li>
<li>
<p><strong>Format Ambiguity</strong>: imagine a program that hashes a pair of strings.
To hash the strings <code>a</code> and <code>b</code> it hashes <code>a + &quot;||&quot; + b</code>. The pair of
strings <code>a=&quot;foo||&quot;, b = &quot;bar&quot;</code> and <code>a=&quot;foo&quot;, b = &quot;||bar&quot;</code> result in the
same input to the hash function and therefore the same hash. This
creates a collision.</p>
</li>
</ol>
<p>Regarding (1), this library makes it easy for Diem developers to create as
many new “hashable” Rust types as needed so that each Rust type hashed and signed
in Diem has a unique meaning, that is, unambiguously captures the intent of a signer.</p>
<p>Regarding (2), this library provides the <code>CryptoHasher</code> abstraction to easily manage
cryptographic seeds for hashing. Hashing seeds aim to ensure that
the hashes of values of a given type <code>MyNewStruct</code> never collide with hashes of values
from another type.</p>
<p>Finally, to prevent format ambiguity within a same type <code>MyNewStruct</code> and facilitate protocol
specifications, we use <a href="https://docs.rs/bcs/">Binary Canonical Serialization (BCS)</a>
as the recommended solution to write Rust values into a hasher.</p>
<h2 id="quick-start"><a href="#quick-start">Quick Start</a></h2>
<p>To obtain a <code>hash()</code> method for any new type <code>MyNewStruct</code>, it is (strongly) recommended to
use the derive macros of <code>serde</code> and <code>diem_crypto_derive</code> as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diem_crypto::hash::CryptoHash;
<span class="kw">use </span>diem_crypto_derive::{CryptoHasher, BCSCryptoHash};
<span class="kw">use </span>serde::{Deserialize, Serialize};
<span class="attr">#[derive(Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
</span><span class="kw">struct </span>MyNewStruct { <span class="comment">/*...*/ </span>}

<span class="kw">let </span>value = MyNewStruct { <span class="comment">/*...*/ </span>};
value.hash();</code></pre></div>
<p>Under the hood, this will generate a new implementation <code>MyNewStructHasher</code> for the trait
<code>CryptoHasher</code> and implement the trait <code>CryptoHash</code> for <code>MyNewStruct</code> using BCS.</p>
<h2 id="implementing-new-hashers"><a href="#implementing-new-hashers">Implementing New Hashers</a></h2>
<p>The trait <code>CryptoHasher</code> captures the notion of a pre-seeded hash function, aka a “hasher”.
New implementations can be defined in two ways.</p>
<h3 id="derive-macro-recommended"><a href="#derive-macro-recommended">Derive macro (recommended)</a></h3>
<p>For any new structure <code>MyNewStruct</code> that needs to be hashed, it is recommended to simply
use the derive macro <a href="https://doc.rust-lang.org/reference/procedural-macros.html"><code>CryptoHasher</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diem_crypto_derive::CryptoHasher;
<span class="kw">use </span>serde::Deserialize;
<span class="attr">#[derive(Deserialize, CryptoHasher)]
#[serde(rename = <span class="string">&quot;OptionalCustomSerdeName&quot;</span>)]
</span><span class="kw">struct </span>MyNewStruct { <span class="comment">/*...*/ </span>}</code></pre></div>
<p>The macro <code>CryptoHasher</code> will define a hasher automatically called <code>MyNewStructHasher</code>, and derive a salt
using the name of the type as seen by the Serde library. In the example above, this name
was changed using the Serde parameter <code>rename</code>: the salt will be based on the value <code>OptionalCustomSerdeName</code>
instead of the default name <code>MyNewStruct</code>.</p>
<h3 id="customized-hashers"><a href="#customized-hashers">Customized hashers</a></h3>
<p><strong>IMPORTANT:</strong> Do NOT use this for new code unless you know what you are doing.</p>
<p>This library also provides a few customized hashers defined in the code as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">define_hasher! </span>{ (MyNewDataHasher, MY_NEW_DATA_HASHER, MY_NEW_DATA_SEED, <span class="string">b&quot;MyUniqueSaltString&quot;</span>) }</code></pre></div>
<h2 id="using-a-hasher-directly"><a href="#using-a-hasher-directly">Using a hasher directly</a></h2>
<p><strong>IMPORTANT:</strong> Do NOT use this for new code unless you know what you are doing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diem_crypto::hash::{CryptoHasher, TestOnlyHasher};

<span class="kw">let </span><span class="kw-2">mut </span>hasher = TestOnlyHasher::default();
hasher.update(<span class="string">&quot;Test message&quot;</span>.as_bytes());
<span class="kw">let </span>hash_value = hasher.finish();</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EventAccumulatorHasher.html" title="diem_crypto::hash::EventAccumulatorHasher struct">EventAccumulatorHasher</a></div><div class="item-right docblock-short">The hasher used to compute the hash of an internal node in the event accumulator.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HashValue.html" title="diem_crypto::hash::HashValue struct">HashValue</a></div><div class="item-right docblock-short">Output value of our hash function. Intentionally opaque for safety and modularity.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HashValueBitIterator.html" title="diem_crypto::hash::HashValueBitIterator struct">HashValueBitIterator</a></div><div class="item-right docblock-short">An iterator over <code>HashValue</code> that generates one bit for each iteration.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.HashValueParseError.html" title="diem_crypto::hash::HashValueParseError struct">HashValueParseError</a></div><div class="item-right docblock-short">Parse error when attempting to construct a HashValue</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SparseMerkleInternalHasher.html" title="diem_crypto::hash::SparseMerkleInternalHasher struct">SparseMerkleInternalHasher</a></div><div class="item-right docblock-short">The hasher used to compute the hash of an internal node in the Sparse Merkle Tree.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TestOnlyHasher.html" title="diem_crypto::hash::TestOnlyHasher struct">TestOnlyHasher</a></div><div class="item-right docblock-short">The hasher used only for testing. It doesn’t have a salt.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TransactionAccumulatorHasher.html" title="diem_crypto::hash::TransactionAccumulatorHasher struct">TransactionAccumulatorHasher</a></div><div class="item-right docblock-short">The hasher used to compute the hash of an internal node in the transaction accumulator.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.VoteProposalHasher.html" title="diem_crypto::hash::VoteProposalHasher struct">VoteProposalHasher</a></div><div class="item-right docblock-short">The hasher used to compute the hash of an internal node in the transaction accumulator.</div></div></div><h2 id="statics" class="small-section-header"><a href="#statics">Statics</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="static" href="static.ACCUMULATOR_PLACEHOLDER_HASH.html" title="diem_crypto::hash::ACCUMULATOR_PLACEHOLDER_HASH static">ACCUMULATOR_PLACEHOLDER_HASH</a></div><div class="item-right docblock-short">Placeholder hash of <code>Accumulator</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.GENESIS_BLOCK_ID.html" title="diem_crypto::hash::GENESIS_BLOCK_ID static">GENESIS_BLOCK_ID</a></div><div class="item-right docblock-short">Genesis block id is used as a parent of the very first block executed by the executor.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.PRE_GENESIS_BLOCK_ID.html" title="diem_crypto::hash::PRE_GENESIS_BLOCK_ID static">PRE_GENESIS_BLOCK_ID</a></div><div class="item-right docblock-short">Block id reserved as the id of parent block of the genesis block.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.SPARSE_MERKLE_PLACEHOLDER_HASH.html" title="diem_crypto::hash::SPARSE_MERKLE_PLACEHOLDER_HASH static">SPARSE_MERKLE_PLACEHOLDER_HASH</a></div><div class="item-right docblock-short">Placeholder hash of <code>SparseMerkleTree</code>.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.CryptoHash.html" title="diem_crypto::hash::CryptoHash trait">CryptoHash</a></div><div class="item-right docblock-short">A type that can be cryptographically hashed to produce a <code>HashValue</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.CryptoHasher.html" title="diem_crypto::hash::CryptoHasher trait">CryptoHasher</a></div><div class="item-right docblock-short">A trait for representing the state of a cryptographic hasher.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.TestOnlyHash.html" title="diem_crypto::hash::TestOnlyHash trait">TestOnlyHash</a></div><div class="item-right docblock-short">Provides a test_only_hash() method that can be used in tests on types that implement
<code>serde::Serialize</code>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="diem_crypto" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0 (fc594f156 2023-01-24)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>